
## 简述TCP协议的三次握手过程

第一次握手：建立连接时，客户端发送SYN包（seq=0,ack=0）到服务器，并进入SYN_SENT状态，等待服务器确认；seq和ack的作用用来表示消息的绝对顺序，分别表示这个消息发送前一共发送了多少字节以及这个消息发送前一共收到了多少个字节。

第二次握手：服务器收到SYN包，必须确认客户端的SYN，同时自己也发送一个SYN包，即SYN+ACK包（seq=0,ack=1），此时服务器进入SYN_RECEIVED状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（seq=1,ack=1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

## 正向代理和反向代理有什么区别？
正向代理与反向代理最简单的区别：
正向代理隐藏的是用户，反向代理隐藏的是服务器

正向代理：当客户端无法访问外部资源的时候（比如墙这样的原因），可以通过一个正向代理去间接地访问，所以客户端需要配置代理服务器的ip.客户端知道正向代理服务器的ip.客户端和正向代理服务器处在同一个局域网.

反向代理：大型网站通常会把外网作为访问地址，此时，反向代理服务器的内网ip和内部网络上的服务器ip处在同一个局域网.这些web服务器对客户端是不透明的，但是对反向代理服务器是透明的(内网ip处在同一个局域网).客户端无法感知代理的存在，因为客户端和反向代理服务器直接打交道的是这个外网ip，也没有设置代理ip的环节，并且反向代理服务器真正进行代理的时候是通过内网ip实现的.

关于透明性问题

正向代理：server和proxy对client都是透明的.client对proxy是透明的，client对server是不透明的.

反向代理：server对client是不透明的，proxy对client是透明的.client对proxy是透明的，client对server是不透明的.(更安全)

## 请简述CDN的工作原理
内容分发网络（Content Delivery Network），它是基于地理位置的分布式代理服务器/数据中心。  
工作原理如下:  
1. 用户在浏览器上发出请求某个网址后，浏览器就会去DNS查询文件所在的IP地址，然后DNS会返回一个CNAME（cdn提供商的别名）给浏览器。  
2. 浏览器拿到CNAME之后会继续到DNS查询，然后DNS会返回一个cdn智能dns服务ip  
3. 浏览器会根据这个ip去智能调度DNS上去查询，然后会得到一个离你所在地址最近的节点ip  
4. 浏览器拿到这个ip之后，再根据这个ip获取到你所请求的静态资源  
当然，还有一种特殊情况  
浏览器在智能调度DNS上面没有找到相关的文件，那么它就会去公司本身的那个机房去查询，
这一操作叫做CDN回源

##  Http2.0有哪些进步？
HTTP2.0在1.0的基础上提出了四个大的优化点，用于解决1.1上比较突出的问题  
1. 多个请求多路复用解决HTTP1.1的排队问题  
我们知道，在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞，而 HTTP2.0 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP2.0 连接发起多重的 请求-响应消息。因此 HTTP2.0 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接
2. 防止队头阻塞  
在 HTTP1.1中，发送数据的时候，如果第一个请求阻塞了，那么后面的也会被阻塞，这种现象被称为队头阻塞，而在 HTTP2.0 中，它是将请求拆成一个个的小块一并发送，一个请求阻塞并不会影响后续的请求回来
3. 压缩HTTP头部  
HTTP1.1并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP2.0 应运而生，SPDY 使用的是通用的 DEFLATE 算法，而 HTTP2.0 则使用了专门为首部压缩而设计的HPACK 算法。
4. 服务端推送  
在 HTTP/1.1中请求一个html，请求到之后会再根据html请求相应的js和css，这样中间就会有一部分时间被浪费。而在2.0中，服务器可以对客户端的一个请求发送多个响应，也就是说如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。

## HTTP缓存